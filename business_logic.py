"""
Business logic for Display Program Management System
Logic nghi·ªáp v·ª• cho H·ªá th·ªëng Qu·∫£n l√Ω Ch∆∞∆°ng tr√¨nh Tr∆∞ng b√†y
Created: 2025-09-19

T·ªáp n√†y ch·ª©a core business logic ƒë·ªÉ:
1. ƒê√°nh gi√° kh√°ch h√†ng theo ti√™u ch√≠ ch∆∞∆°ng tr√¨nh (Customer Evaluation)
2. X√°c ƒë·ªãnh quy·ªÅn nh·∫≠n th∆∞·ªüng (Reward Eligibility)
3. T·∫°o b√°o c√°o v√† th·ªëng k√™ (Reporting)
4. Validate business rules (Validation)

BUSINESS FLOW T·ªîNG QUAN:
=========================
1. [Operations] C·∫•u h√¨nh ch∆∞∆°ng tr√¨nh trong register_item
2. [Operations] Thi·∫øt l·∫≠p ti√™u ch√≠ ƒë√°nh gi√° trong condition_group + condition_item
3. [Customers] ƒêƒÉng k√Ω tham gia ch∆∞∆°ng tr√¨nh trong register
4. [Supervisors] Th·ª±c hi·ªán audit t·∫°i ƒëi·ªÉm b√°n, ghi k·∫øt qu·∫£ v√†o audit_picture
5. [System] ƒê√°nh gi√° customer theo ti√™u ch√≠ v√† x√°c ƒë·ªãnh quy·ªÅn nh·∫≠n th∆∞·ªüng

CUSTOMER EVALUATION FLOW:
========================
Step 1: Ki·ªÉm tra ƒëƒÉng k√Ω (Registration Check)
Step 2: L·∫•y ti√™u ch√≠ ch∆∞∆°ng tr√¨nh (Get Program Criteria)
Step 3: L·∫•y k·∫øt qu·∫£ audit (Get Audit Results)
Step 4: So s√°nh audit vs ti√™u ch√≠ (Compare & Calculate Points)
Step 5: X√°c ƒë·ªãnh ƒë·ªß ƒëi·ªÅu ki·ªán (Determine Eligibility)
"""

import logging
from typing import List, Dict, Optional, Tuple
from collections import defaultdict

from models import (
    RegisterItem, Register, ConditionGroup, ConditionItem, 
    AuditPicture, CustomerEvaluationResult
)
from database import DisplayProgramRepository


class DisplayProgramService:
    """
    Service class ch√≠nh cho qu·∫£n l√Ω ch∆∞∆°ng tr√¨nh tr∆∞ng b√†y
    
    Class n√†y ch·ª©a t·∫•t c·∫£ business logic ƒë·ªÉ:
    - ƒê√°nh gi√° kh√°ch h√†ng theo ti√™u ch√≠ ch∆∞∆°ng tr√¨nh
    - X√°c ƒë·ªãnh quy·ªÅn nh·∫≠n th∆∞·ªüng
    - T·∫°o b√°o c√°o v√† th·ªëng k√™
    - Validate c√°c business rules
    
    Attributes:
        repo (DisplayProgramRepository): Repository ƒë·ªÉ truy c·∫≠p d·ªØ li·ªáu
        logger (Logger): Logger ƒë·ªÉ ghi log c√°c thao t√°c
    """
    
    def __init__(self, repository: DisplayProgramRepository):
        """
        Kh·ªüi t·∫°o service v·ªõi repository
        
        Args:
            repository: Repository instance ƒë·ªÉ truy c·∫≠p database
        """
        self.repo = repository
        self.logger = logging.getLogger(__name__)
        
        self.logger.info("DisplayProgramService initialized")
    
    def evaluate_customer(self, yyyymm: int, customer_code: str, program_code: str) -> CustomerEvaluationResult:
        """
        üéØ CORE METHOD: ƒê√°nh gi√° kh√°ch h√†ng c√≥ ƒë·ªß ƒëi·ªÅu ki·ªán nh·∫≠n th∆∞·ªüng hay kh√¥ng
        
        ƒê√¢y l√† method quan tr·ªçng nh·∫•t c·ªßa h·ªá th·ªëng, th·ª±c hi·ªán vi·ªác ƒë√°nh gi√° to√†n di·ªán
        m·ªôt kh√°ch h√†ng theo c√°c ti√™u ch√≠ c·ªßa ch∆∞∆°ng tr√¨nh ƒë·ªÉ x√°c ƒë·ªãnh quy·ªÅn nh·∫≠n th∆∞·ªüng.
        
        üìã DETAILED EVALUATION FLOW:
        ============================
        
        STEP 1: KI·ªÇM TRA ƒêƒÇNG K√ù (Registration Verification)
        ---------------------------------------------------
        - L·∫•y t·∫•t c·∫£ ƒëƒÉng k√Ω c·ªßa customer trong th√°ng (bao g·ªìm c·∫£ inactive)
        - T√¨m ƒëƒÉng k√Ω c·ª• th·ªÉ cho program_code
        - N·∫øu kh√¥ng c√≥ ƒëƒÉng k√Ω ‚Üí LO·∫†I (NOT_REGISTERED)
        
        STEP 2: L·∫§Y TI√äU CH√ç CH∆Ø∆†NG TR√åNH (Get Program Criteria)
        --------------------------------------------------------
        - L·∫•y t·∫•t c·∫£ condition_items c·ªßa program trong th√°ng
        - M·ªói condition_item c√≥: condition_code, min_value, points
        - N·∫øu kh√¥ng c√≥ ti√™u ch√≠ ‚Üí LO·∫†I (NO_CONDITIONS_DEFINED)
        
        STEP 3: L·∫§Y K·∫æT QU·∫¢ AUDIT (Get Audit Results)
        ---------------------------------------------
        - L·∫•y t·∫•t c·∫£ audit_picture c·ªßa customer trong th√°ng
        - T·∫°o dictionary mapping: condition_code ‚Üí audit_result
        - Audit results ch·ª©a gi√° tr·ªã th·ª±c t·∫ø ƒëo ƒë∆∞·ª£c t·∫°i ƒëi·ªÉm b√°n
        
        STEP 4: SO S√ÅNH & T√çNH ƒêI·ªÇM (Compare & Calculate Points)
        --------------------------------------------------------
        For m·ªói condition_item:
        a) C·ªông condition_point v√†o max_possible_points
        b) Ki·ªÉm tra c√≥ audit_result t∆∞∆°ng ·ª©ng kh√¥ng
           - N·∫øu kh√¥ng c√≥ ‚Üí Th√™m v√†o failed_conditions: "CONDITION_NOT_AUDITED"
           - N·∫øu c√≥ ‚Üí Ti·∫øp t·ª•c step c
        c) So s√°nh actual_value vs condition_min_value
           - N·∫øu actual_value >= min_value ‚Üí ƒê·∫°t ti√™u ch√≠, c·ªông ƒëi·ªÉm
           - N·∫øu actual_value < min_value ‚Üí Kh√¥ng ƒë·∫°t, th√™m v√†o failed_conditions
        
        STEP 5: X√ÅC ƒê·ªäNH K·∫æT QU·∫¢ CU·ªêI C√ôNG (Final Determination)
        --------------------------------------------------------
        - meets_criteria = True n·∫øu failed_conditions r·ªóng (ƒë·∫°t T·∫§T C·∫¢ ti√™u ch√≠)
        - is_eligible_for_reward = meets_criteria AND registration_status = active
        
        Args:
            yyyymm (int): Th√°ng/nƒÉm ƒë√°nh gi√° (format YYYYMM)
            customer_code (str): M√£ kh√°ch h√†ng c·∫ßn ƒë√°nh gi√°
            program_code (str): M√£ ch∆∞∆°ng tr√¨nh c·∫ßn ƒë√°nh gi√°
        
        Returns:
            CustomerEvaluationResult: K·∫øt qu·∫£ ƒë√°nh gi√° chi ti·∫øt bao g·ªìm:
                - total_points: T·ªïng ƒëi·ªÉm ƒë·∫°t ƒë∆∞·ª£c
                - max_possible_points: T·ªïng ƒëi·ªÉm t·ªëi ƒëa c√≥ th·ªÉ ƒë·∫°t
                - meets_criteria: C√≥ ƒë·∫°t t·∫•t c·∫£ ti√™u ch√≠ kh√¥ng
                - failed_conditions: Danh s√°ch ti√™u ch√≠ kh√¥ng ƒë·∫°t
                - registration_status: Tr·∫°ng th√°i ƒëƒÉng k√Ω (active/inactive)
        
        Business Rules:
            1. Customer PH·∫¢I c√≥ ƒëƒÉng k√Ω cho program
            2. Program PH·∫¢I c√≥ √≠t nh·∫•t 1 condition ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a
            3. Customer PH·∫¢I ƒë∆∞·ª£c audit cho T·∫§T C·∫¢ c√°c conditions
            4. Customer PH·∫¢I ƒë·∫°t minimum value cho T·∫§T C·∫¢ conditions
            5. Ch·ªâ ƒëƒÉng k√Ω ACTIVE m·ªõi c√≥ quy·ªÅn nh·∫≠n th∆∞·ªüng
        
        Example:
            >>> service = DisplayProgramService(repo)
            >>> result = service.evaluate_customer(202509, "CUST001", "PROG001")
            >>> if result.is_eligible_for_reward:
            ...     print(f"Customer ƒë·ªß ƒëi·ªÅu ki·ªán nh·∫≠n th∆∞·ªüng: {result.total_points}/{result.max_possible_points} ƒëi·ªÉm")
            ... else:
            ...     print(f"Customer kh√¥ng ƒë·ªß ƒëi·ªÅu ki·ªán: {result.get_failure_summary()}")
        """
        
        self.logger.info(f"üîç Starting evaluation for customer {customer_code} in program {program_code} ({yyyymm})")
        
        # ==========================================
        # STEP 1: KI·ªÇM TRA ƒêƒÇNG K√ù
        # ==========================================
        self.logger.debug(f"Step 1: Checking registration for {customer_code}")
        
        # L·∫•y T·∫§T C·∫¢ ƒëƒÉng k√Ω c·ªßa customer (bao g·ªìm c·∫£ inactive) ƒë·ªÉ ki·ªÉm tra ƒë·∫ßy ƒë·ªß
        registrations = self.repo.get_registrations(yyyymm, customer_code, active_only=False)
        
        # T√¨m ƒëƒÉng k√Ω c·ª• th·ªÉ cho program n√†y
        program_registration = next(
            (r for r in registrations if r.program_code == program_code), 
            None
        )
        
        # N·∫øu kh√¥ng c√≥ ƒëƒÉng k√Ω ‚Üí LO·∫†I ngay
        if not program_registration:
            self.logger.warning(f"‚ùå Customer {customer_code} not registered for program {program_code}")
            return CustomerEvaluationResult(
                yyyymm=yyyymm,
                customer_code=customer_code,
                program_code=program_code,
                total_points=0,
                max_possible_points=0,
                meets_criteria=False,
                failed_conditions=["NOT_REGISTERED"],
                registration_status=False
            )
        
        self.logger.debug(f"‚úÖ Registration found - Status: {'Active' if program_registration.is_active else 'Inactive'}")
        
        # ==========================================
        # STEP 2: L·∫§Y TI√äU CH√ç CH∆Ø∆†NG TR√åNH
        # ==========================================
        self.logger.debug(f"Step 2: Getting program criteria for {program_code}")
        
        # L·∫•y t·∫•t c·∫£ condition_items c·ªßa program trong th√°ng n√†y
        condition_items = self.repo.get_condition_items(yyyymm, program_code)
        
        # N·∫øu program kh√¥ng c√≥ ti√™u ch√≠ ‚Üí LO·∫†I (l·ªói c·∫•u h√¨nh)
        if not condition_items:
            self.logger.error(f"‚ùå No conditions defined for program {program_code} in {yyyymm}")
            return CustomerEvaluationResult(
                yyyymm=yyyymm,
                customer_code=customer_code,
                program_code=program_code,
                total_points=0,
                max_possible_points=0,
                meets_criteria=False,
                failed_conditions=["NO_CONDITIONS_DEFINED"],
                registration_status=program_registration.is_active
            )
        
        self.logger.debug(f"‚úÖ Found {len(condition_items)} conditions for program {program_code}")
        
        # ==========================================
        # STEP 3: L·∫§Y K·∫æT QU·∫¢ AUDIT
        # ==========================================
        self.logger.debug(f"Step 3: Getting audit results for {customer_code}")
        
        # L·∫•y t·∫•t c·∫£ audit results c·ªßa customer trong th√°ng
        audit_results = self.repo.get_audit_results(yyyymm, customer_code)
        
        # T·∫°o dictionary ƒë·ªÉ lookup nhanh: condition_code ‚Üí audit_result
        audit_dict = {audit.condition_code: audit for audit in audit_results}
        
        self.logger.debug(f"‚úÖ Found audit results for {len(audit_dict)} conditions")
        
        # ==========================================
        # STEP 4: SO S√ÅNH & T√çNH ƒêI·ªÇM
        # ==========================================
        self.logger.debug(f"Step 4: Comparing audit results vs criteria")
        
        # Kh·ªüi t·∫°o variables ƒë·ªÉ t√≠nh to√°n
        total_points = 0              # T·ªïng ƒëi·ªÉm customer ƒë·∫°t ƒë∆∞·ª£c
        max_possible_points = 0       # T·ªïng ƒëi·ªÉm t·ªëi ƒëa c√≥ th·ªÉ ƒë·∫°t
        failed_conditions = []        # Danh s√°ch c√°c l√Ω do th·∫•t b·∫°i
        
        # Duy·ªát qua t·ª´ng ti√™u ch√≠ c·ªßa program
        for condition in condition_items:
            # C·ªông ƒëi·ªÉm t·ªëi ƒëa c√≥ th·ªÉ ƒë·∫°t
            max_possible_points += condition.condition_point
            
            self.logger.debug(f"  üìä Evaluating condition: {condition.condition_code} "
                            f"(min: {condition.condition_min_value}, points: {condition.condition_point})")
            
            # Ki·ªÉm tra c√≥ k·∫øt qu·∫£ audit cho condition n√†y kh√¥ng
            audit_result = audit_dict.get(condition.condition_code)
            if not audit_result:
                # Kh√¥ng c√≥ audit ‚Üí TH·∫§T B·∫†I
                failure_reason = f"{condition.condition_code}_NOT_AUDITED"
                failed_conditions.append(failure_reason)
                self.logger.debug(f"    ‚ùå No audit result found for {condition.condition_code}")
                continue
            
            # L·∫•y gi√° tr·ªã th·ª±c t·∫ø t·ª´ audit
            actual_value = audit_result.numeric_value
            
            # So s√°nh v·ªõi y√™u c·∫ßu t·ªëi thi·ªÉu
            if condition.meets_minimum(actual_value):
                # ƒê·∫†T y√™u c·∫ßu ‚Üí C·ªông ƒëi·ªÉm
                total_points += condition.condition_point
                self.logger.debug(f"    ‚úÖ PASSED: {actual_value} >= {condition.condition_min_value} "
                                f"‚Üí +{condition.condition_point} points")
            else:
                # KH√îNG ƒê·∫†T y√™u c·∫ßu ‚Üí Th√™m v√†o failed list
                failure_reason = (f"{condition.condition_code}_BELOW_MINIMUM"
                                f"({actual_value}<{condition.condition_min_value})")
                failed_conditions.append(failure_reason)
                self.logger.debug(f"    ‚ùå FAILED: {actual_value} < {condition.condition_min_value} "
                                f"‚Üí No points")
        
        # ==========================================
        # STEP 5: X√ÅC ƒê·ªäNH K·∫æT QU·∫¢ CU·ªêI C√ôNG
        # ==========================================
        self.logger.debug(f"Step 5: Determining final result")
        
        # Customer ch·ªâ ƒë·∫°t ti√™u ch√≠ n·∫øu KH√îNG c√≥ l·ªói n√†o
        meets_criteria = len(failed_conditions) == 0
        
        # T√≠nh success rate
        success_rate = (total_points / max_possible_points * 100) if max_possible_points > 0 else 0
        
        # Log k·∫øt qu·∫£ cu·ªëi c√πng
        if meets_criteria:
            self.logger.info(f"üéâ EVALUATION SUCCESS: {customer_code} meets all criteria "
                           f"({total_points}/{max_possible_points} points, {success_rate:.1f}%)")
        else:
            self.logger.info(f"üí• EVALUATION FAILED: {customer_code} failed {len(failed_conditions)} conditions "
                           f"({total_points}/{max_possible_points} points, {success_rate:.1f}%)")
            for failure in failed_conditions:
                self.logger.debug(f"    ‚ùå {failure}")
        
        # T·∫°o v√† tr·∫£ v·ªÅ k·∫øt qu·∫£ ƒë√°nh gi√°
        result = CustomerEvaluationResult(
            yyyymm=yyyymm,
            customer_code=customer_code,
            program_code=program_code,
            total_points=total_points,
            max_possible_points=max_possible_points,
            meets_criteria=meets_criteria,
            failed_conditions=failed_conditions,
            registration_status=program_registration.is_active
        )
        
        # Log th√¥ng tin v·ªÅ quy·ªÅn nh·∫≠n th∆∞·ªüng
        if result.is_eligible_for_reward:
            self.logger.info(f"üèÜ REWARD ELIGIBLE: {customer_code} is eligible for rewards")
        else:
            reason = "inactive registration" if not result.registration_status else "failed criteria"
            self.logger.info(f"üö´ REWARD INELIGIBLE: {customer_code} not eligible due to {reason}")
        
        return result
    
    def evaluate_all_customers_for_program(self, yyyymm: int, program_code: str) -> List[CustomerEvaluationResult]:
        """
        üìä ƒê√°nh gi√° T·∫§T C·∫¢ kh√°ch h√†ng ƒëƒÉng k√Ω m·ªôt ch∆∞∆°ng tr√¨nh c·ª• th·ªÉ
        
        Method n√†y s·ª≠ d·ª•ng evaluate_customer() ƒë·ªÉ ƒë√°nh gi√° t·ª´ng kh√°ch h√†ng
        m·ªôt c√°ch ri√™ng bi·ªát, sau ƒë√≥ t·ªïng h·ª£p k·∫øt qu·∫£.
        
        Flow:
        1. L·∫•y danh s√°ch t·∫•t c·∫£ customers ƒëƒÉng k√Ω program (ch·ªâ active)
        2. For m·ªói customer: g·ªçi evaluate_customer()
        3. T·ªïng h·ª£p t·∫•t c·∫£ k·∫øt qu·∫£ v√†o m·ªôt list
        
        Args:
            yyyymm: Th√°ng/nƒÉm ƒë√°nh gi√°
            program_code: M√£ ch∆∞∆°ng tr√¨nh c·∫ßn ƒë√°nh gi√°
            
        Returns:
            List[CustomerEvaluationResult]: Danh s√°ch k·∫øt qu·∫£ ƒë√°nh gi√° c·ªßa t·∫•t c·∫£ customers
            
        Use Case:
            - T·∫°o b√°o c√°o hi·ªáu su·∫•t ch∆∞∆°ng tr√¨nh
            - X√°c ƒë·ªãnh t·ª∑ l·ªá th√†nh c√¥ng c·ªßa ch∆∞∆°ng tr√¨nh
            - Ph√¢n t√≠ch l√Ω do th·∫•t b·∫°i ph·ªï bi·∫øn
        """
        self.logger.info(f"üîç Evaluating all customers for program {program_code} ({yyyymm})")
        
        # L·∫•y danh s√°ch customers ƒë√£ ƒëƒÉng k√Ω program (ch·ªâ active)
        customers = self.repo.get_program_customers(yyyymm, program_code)
        results = []
        
        self.logger.debug(f"Found {len(customers)} customers registered for {program_code}")
        
        # ƒê√°nh gi√° t·ª´ng customer
        for customer_code in customers:
            self.logger.debug(f"Evaluating customer {customer_code}...")
            result = self.evaluate_customer(yyyymm, customer_code, program_code)
            results.append(result)
        
        # Log summary
        eligible_count = sum(1 for r in results if r.is_eligible_for_reward)
        self.logger.info(f"üìä Program {program_code} evaluation complete: "
                        f"{eligible_count}/{len(results)} customers eligible for rewards")
        
        return results
    
    def evaluate_customer_all_programs(self, yyyymm: int, customer_code: str) -> List[CustomerEvaluationResult]:
        """Evaluate a customer against all programs they're registered for"""
        programs = self.repo.get_customer_programs(yyyymm, customer_code)
        results = []
        
        for program_code in programs:
            result = self.evaluate_customer(yyyymm, customer_code, program_code)
            results.append(result)
        
        return results
    
    def get_eligible_customers_for_rewards(self, yyyymm: int, program_code: str = None) -> List[CustomerEvaluationResult]:
        """
        üèÜ L·∫•y danh s√°ch kh√°ch h√†ng ƒê·ª¶ ƒêI·ªÄU KI·ªÜN nh·∫≠n th∆∞·ªüng
        
        Method n√†y l√† output ch√≠nh c·ªßa h·ªá th·ªëng - x√°c ƒë·ªãnh customers n√†o
        s·∫Ω ƒë∆∞·ª£c tr·∫£ th∆∞·ªüng d·ª±a tr√™n k·∫øt qu·∫£ ƒë√°nh gi√°.
        
        REWARD ELIGIBILITY CRITERIA:
        ============================
        Customer ƒë∆∞·ª£c coi l√† ƒë·ªß ƒëi·ªÅu ki·ªán nh·∫≠n th∆∞·ªüng khi:
        1. C√≥ ƒëƒÉng k√Ω ACTIVE cho ch∆∞∆°ng tr√¨nh
        2. ƒê·∫†T T·∫§T C·∫¢ ti√™u ch√≠ t·ªëi thi·ªÉu (meets_criteria = True)
        3. ƒê√£ ƒë∆∞·ª£c audit ƒë·∫ßy ƒë·ªß cho t·∫•t c·∫£ conditions
        
        Args:
            yyyymm: Th√°ng/nƒÉm c·∫ßn l·∫•y danh s√°ch
            program_code: M√£ ch∆∞∆°ng tr√¨nh c·ª• th·ªÉ (None = t·∫•t c·∫£ ch∆∞∆°ng tr√¨nh)
            
        Returns:
            List[CustomerEvaluationResult]: Ch·ªâ nh·ªØng customers ƒë·ªß ƒëi·ªÅu ki·ªán nh·∫≠n th∆∞·ªüng
            
        Business Impact:
            - K·∫øt qu·∫£ n√†y ƒë∆∞·ª£c d√πng ƒë·ªÉ t√≠nh to√°n s·ªë ti·ªÅn th∆∞·ªüng
            - T·∫°o danh s√°ch thanh to√°n hoa h·ªìng
            - B√°o c√°o hi·ªáu qu·∫£ ch∆∞∆°ng tr√¨nh cho management
        """
        self.logger.info(f"üèÜ Getting eligible customers for rewards ({yyyymm})")
        
        if program_code:
            # ƒê√°nh gi√° cho ch∆∞∆°ng tr√¨nh c·ª• th·ªÉ
            self.logger.debug(f"Evaluating specific program: {program_code}")
            results = self.evaluate_all_customers_for_program(yyyymm, program_code)
        else:
            # ƒê√°nh gi√° cho T·∫§T C·∫¢ ch∆∞∆°ng tr√¨nh
            self.logger.debug("Evaluating all programs")
            results = []
            registrations = self.repo.get_registrations(yyyymm, active_only=True)
            processed = set()  # Tr√°nh ƒë√°nh gi√° tr√πng l·∫∑p
            
            for reg in registrations:
                key = (reg.customer_code, reg.program_code)
                if key not in processed:
                    result = self.evaluate_customer(yyyymm, reg.customer_code, reg.program_code)
                    results.append(result)
                    processed.add(key)
        
        # L·ªçc ch·ªâ l·∫•y customers ƒë·ªß ƒëi·ªÅu ki·ªán nh·∫≠n th∆∞·ªüng
        eligible_customers = [r for r in results if r.is_eligible_for_reward]
        
        # Log k·∫øt qu·∫£
        total_evaluated = len(results)
        eligible_count = len(eligible_customers)
        eligibility_rate = (eligible_count / total_evaluated * 100) if total_evaluated > 0 else 0
        
        self.logger.info(f"üéØ REWARD ELIGIBILITY SUMMARY: {eligible_count}/{total_evaluated} customers eligible "
                        f"({eligibility_rate:.1f}% success rate)")
        
        # Log chi ti·∫øt customers ƒë·ªß ƒëi·ªÅu ki·ªán
        if eligible_customers:
            self.logger.debug("Eligible customers:")
            for result in eligible_customers:
                self.logger.debug(f"  ‚úÖ {result.customer_code} - {result.program_code}: "
                                f"{result.total_points}/{result.max_possible_points} points")
        
        return eligible_customers
    
    def get_failed_customers(self, yyyymm: int, program_code: str = None) -> List[CustomerEvaluationResult]:
        """Get customers who failed to meet criteria"""
        if program_code:
            results = self.evaluate_all_customers_for_program(yyyymm, program_code)
        else:
            # Evaluate all customers for all programs
            results = []
            registrations = self.repo.get_registrations(yyyymm, active_only=True)
            processed = set()
            
            for reg in registrations:
                key = (reg.customer_code, reg.program_code)
                if key not in processed:
                    result = self.evaluate_customer(yyyymm, reg.customer_code, reg.program_code)
                    results.append(result)
                    processed.add(key)
        
        # Filter only failed customers (registered and active but not meeting criteria)
        return [r for r in results if r.registration_status and not r.meets_criteria]
    
    def generate_program_summary(self, yyyymm: int, program_code: str) -> Dict:
        """Generate summary report for a program"""
        results = self.evaluate_all_customers_for_program(yyyymm, program_code)
        
        eligible_count = sum(1 for r in results if r.is_eligible_for_reward)
        failed_count = sum(1 for r in results if r.registration_status and not r.meets_criteria)
        inactive_count = sum(1 for r in results if not r.registration_status)
        
        # Get condition items for reference
        condition_items = self.repo.get_condition_items(yyyymm, program_code)
        condition_groups = self.repo.get_condition_groups(yyyymm, program_code)
        
        # Analyze common failure reasons
        failure_analysis = defaultdict(int)
        for result in results:
            if not result.meets_criteria:
                for failure in result.failed_conditions:
                    failure_analysis[failure] += 1
        
        return {
            'yyyymm': yyyymm,
            'program_code': program_code,
            'total_customers': len(results),
            'eligible_customers': eligible_count,
            'failed_customers': failed_count,
            'inactive_customers': inactive_count,
            'success_rate': (eligible_count / len(results) * 100) if results else 0,
            'condition_groups': len(condition_groups),
            'condition_items': len(condition_items),
            'common_failures': dict(failure_analysis),
            'detailed_results': results
        }
    
    def generate_customer_summary(self, yyyymm: int, customer_code: str) -> Dict:
        """Generate summary report for a customer"""
        results = self.evaluate_customer_all_programs(yyyymm, customer_code)
        
        eligible_programs = [r for r in results if r.is_eligible_for_reward]
        failed_programs = [r for r in results if r.registration_status and not r.meets_criteria]
        
        total_points = sum(r.total_points for r in results)
        max_possible_points = sum(r.max_possible_points for r in results)
        
        return {
            'yyyymm': yyyymm,
            'customer_code': customer_code,
            'total_programs': len(results),
            'eligible_programs': len(eligible_programs),
            'failed_programs': len(failed_programs),
            'total_points': total_points,
            'max_possible_points': max_possible_points,
            'overall_success_rate': (total_points / max_possible_points * 100) if max_possible_points > 0 else 0,
            'program_details': results
        }
    
    def generate_monthly_report(self, yyyymm: int) -> Dict:
        """Generate comprehensive monthly report"""
        # Get basic statistics
        stats = self.repo.get_monthly_statistics(yyyymm)
        
        # Get all active registrations
        registrations = self.repo.get_registrations(yyyymm, active_only=True)
        
        # Group by program
        program_results = {}
        customer_results = {}
        
        processed_combinations = set()
        
        for reg in registrations:
            key = (reg.customer_code, reg.program_code)
            if key not in processed_combinations:
                result = self.evaluate_customer(yyyymm, reg.customer_code, reg.program_code)
                
                # Add to program results
                if reg.program_code not in program_results:
                    program_results[reg.program_code] = []
                program_results[reg.program_code].append(result)
                
                # Add to customer results
                if reg.customer_code not in customer_results:
                    customer_results[reg.customer_code] = []
                customer_results[reg.customer_code].append(result)
                
                processed_combinations.add(key)
        
        # Calculate overall metrics
        all_results = []
        for program_list in program_results.values():
            all_results.extend(program_list)
        
        total_eligible = sum(1 for r in all_results if r.is_eligible_for_reward)
        total_failed = sum(1 for r in all_results if r.registration_status and not r.meets_criteria)
        
        return {
            'yyyymm': yyyymm,
            'basic_stats': stats,
            'total_evaluations': len(all_results),
            'total_eligible_for_rewards': total_eligible,
            'total_failed_criteria': total_failed,
            'overall_success_rate': (total_eligible / len(all_results) * 100) if all_results else 0,
            'program_summaries': {
                program: self.generate_program_summary(yyyymm, program) 
                for program in program_results.keys()
            },
            'customer_summaries': {
                customer: self.generate_customer_summary(yyyymm, customer) 
                for customer in customer_results.keys()
            }
        }
    
    def validate_registration(self, registration: Register) -> Tuple[bool, List[str]]:
        """Validate if a registration is valid"""
        errors = []
        
        # Check if program exists
        register_items = self.repo.get_register_items(registration.yyyymm, registration.program_code)
        if not register_items:
            errors.append(f"Program {registration.program_code} not found for {registration.yyyymm}")
            return False, errors
        
        # Check if display type is valid for the program
        valid_display_types = [item.item for item in register_items]
        if registration.display_type not in valid_display_types:
            errors.append(f"Display type {registration.display_type} not valid for program {registration.program_code}")
        
        # Check quantity is positive
        if registration.register_qty <= 0:
            errors.append("Registration quantity must be positive")
        
        return len(errors) == 0, errors
    
    def explain_evaluation_flow(self, yyyymm: int, customer_code: str, program_code: str) -> str:
        """
        üìñ GI·∫¢I TH√çCH CHI TI·∫æT FLOW ƒê√ÅNH GI√Å CUSTOMER
        
        Method n√†y t·∫°o ra m·ªôt b√°o c√°o chi ti·∫øt v·ªÅ qu√° tr√¨nh ƒë√°nh gi√° customer,
        gi√∫p hi·ªÉu r√µ t·∫°i sao customer ƒë·∫°t ho·∫∑c kh√¥ng ƒë·∫°t ti√™u ch√≠.
        
        Returns:
            str: B√°o c√°o chi ti·∫øt v·ªÅ qu√° tr√¨nh ƒë√°nh gi√°
        """
        
        explanation = []
        explanation.append("=" * 80)
        explanation.append(f"üìã CUSTOMER EVALUATION FLOW EXPLANATION")
        explanation.append(f"    Gi·∫£i th√≠ch chi ti·∫øt qu√° tr√¨nh ƒë√°nh gi√° kh√°ch h√†ng")
        explanation.append("=" * 80)
        explanation.append(f"üéØ Customer: {customer_code}")
        explanation.append(f"üéØ Program: {program_code}")
        explanation.append(f"üéØ Month: {yyyymm}")
        explanation.append("")
        
        # STEP 1: Registration Check
        explanation.append("STEP 1: KI·ªÇM TRA ƒêƒÇNG K√ù (Registration Check)")
        explanation.append("-" * 50)
        
        registrations = self.repo.get_registrations(yyyymm, customer_code, active_only=False)
        program_registration = next((r for r in registrations if r.program_code == program_code), None)
        
        if not program_registration:
            explanation.append("‚ùå RESULT: Customer KH√îNG c√≥ ƒëƒÉng k√Ω cho program n√†y")
            explanation.append("   ‚Üí LO·∫†I NGAY - Kh√¥ng ƒë·ªß ƒëi·ªÅu ki·ªán nh·∫≠n th∆∞·ªüng")
            return "\n".join(explanation)
        
        explanation.append(f"‚úÖ RESULT: T√¨m th·∫•y ƒëƒÉng k√Ω")
        explanation.append(f"   - Display Type: {program_registration.display_type}")
        explanation.append(f"   - Quantity: {program_registration.register_qty}")
        explanation.append(f"   - Status: {'ACTIVE' if program_registration.is_active else 'INACTIVE'}")
        explanation.append("")
        
        # STEP 2: Program Criteria
        explanation.append("STEP 2: L·∫§Y TI√äU CH√ç CH∆Ø∆†NG TR√åNH (Get Program Criteria)")
        explanation.append("-" * 50)
        
        condition_items = self.repo.get_condition_items(yyyymm, program_code)
        
        if not condition_items:
            explanation.append("‚ùå RESULT: Program KH√îNG c√≥ ti√™u ch√≠ ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a")
            explanation.append("   ‚Üí LO·∫†I - L·ªói c·∫•u h√¨nh ch∆∞∆°ng tr√¨nh")
            return "\n".join(explanation)
        
        explanation.append(f"‚úÖ RESULT: T√¨m th·∫•y {len(condition_items)} ti√™u ch√≠ ƒë√°nh gi√°")
        explanation.append("   Danh s√°ch ti√™u ch√≠:")
        
        total_max_points = 0
        for i, condition in enumerate(condition_items, 1):
            total_max_points += condition.condition_point
            explanation.append(f"   {i}. {condition.condition_code}:")
            explanation.append(f"      - Y√™u c·∫ßu t·ªëi thi·ªÉu: {condition.condition_min_value}")
            explanation.append(f"      - ƒêi·ªÉm n·∫øu ƒë·∫°t: {condition.condition_point}")
        
        explanation.append(f"   üìä T·ªïng ƒëi·ªÉm t·ªëi ƒëa c√≥ th·ªÉ ƒë·∫°t: {total_max_points}")
        explanation.append("")
        
        # STEP 3: Audit Results
        explanation.append("STEP 3: L·∫§Y K·∫æT QU·∫¢ AUDIT (Get Audit Results)")
        explanation.append("-" * 50)
        
        audit_results = self.repo.get_audit_results(yyyymm, customer_code)
        audit_dict = {audit.condition_code: audit for audit in audit_results}
        
        explanation.append(f"‚úÖ RESULT: T√¨m th·∫•y k·∫øt qu·∫£ audit cho {len(audit_dict)} ti√™u ch√≠")
        explanation.append("   K·∫øt qu·∫£ audit:")
        
        for condition_code, audit in audit_dict.items():
            explanation.append(f"   - {condition_code}: {audit.value}")
            if audit.audit_date:
                explanation.append(f"     (Audit date: {audit.audit_date.strftime('%Y-%m-%d %H:%M')})")
        explanation.append("")
        
        # STEP 4: Comparison & Calculation
        explanation.append("STEP 4: SO S√ÅNH & T√çNH ƒêI·ªÇM (Compare & Calculate Points)")
        explanation.append("-" * 50)
        
        total_points = 0
        failed_conditions = []
        
        for i, condition in enumerate(condition_items, 1):
            explanation.append(f"   {i}. ƒê√°nh gi√° ti√™u ch√≠: {condition.condition_code}")
            
            audit_result = audit_dict.get(condition.condition_code)
            if not audit_result:
                explanation.append(f"      ‚ùå KH√îNG c√≥ k·∫øt qu·∫£ audit")
                explanation.append(f"      ‚Üí Th·∫•t b·∫°i: {condition.condition_code}_NOT_AUDITED")
                failed_conditions.append(f"{condition.condition_code}_NOT_AUDITED")
                continue
            
            actual_value = audit_result.numeric_value
            explanation.append(f"      üìä Gi√° tr·ªã th·ª±c t·∫ø: {actual_value}")
            explanation.append(f"      üìä Y√™u c·∫ßu t·ªëi thi·ªÉu: {condition.condition_min_value}")
            
            if condition.meets_minimum(actual_value):
                total_points += condition.condition_point
                explanation.append(f"      ‚úÖ ƒê·∫†T y√™u c·∫ßu ‚Üí +{condition.condition_point} ƒëi·ªÉm")
            else:
                failure_reason = f"{condition.condition_code}_BELOW_MINIMUM({actual_value}<{condition.condition_min_value})"
                failed_conditions.append(failure_reason)
                explanation.append(f"      ‚ùå KH√îNG ƒê·∫†T y√™u c·∫ßu ‚Üí 0 ƒëi·ªÉm")
                explanation.append(f"      ‚Üí Th·∫•t b·∫°i: {failure_reason}")
        
        explanation.append("")
        explanation.append(f"üìä T·ªîNG K·∫æT ƒêI·ªÇM: {total_points}/{total_max_points}")
        success_rate = (total_points / total_max_points * 100) if total_max_points > 0 else 0
        explanation.append(f"üìä T·ª∂ L·ªÜ TH√ÄNH C√îNG: {success_rate:.1f}%")
        explanation.append("")
        
        # STEP 5: Final Determination
        explanation.append("STEP 5: X√ÅC ƒê·ªäNH K·∫æT QU·∫¢ CU·ªêI C√ôNG (Final Determination)")
        explanation.append("-" * 50)
        
        meets_criteria = len(failed_conditions) == 0
        
        explanation.append(f"üéØ ƒê·∫°t t·∫•t c·∫£ ti√™u ch√≠: {'C√ì' if meets_criteria else 'KH√îNG'}")
        explanation.append(f"üéØ ƒêƒÉng k√Ω active: {'C√ì' if program_registration.is_active else 'KH√îNG'}")
        
        is_eligible = meets_criteria and program_registration.is_active
        
        explanation.append("")
        explanation.append("üèÜ K·∫æT QU·∫¢ CU·ªêI C√ôNG:")
        if is_eligible:
            explanation.append("   ‚úÖ CUSTOMER ƒê·ª¶ ƒêI·ªÄU KI·ªÜN NH·∫¨N TH∆Ø·ªûNG")
            explanation.append("   üéâ S·∫Ω ƒë∆∞·ª£c t√≠nh hoa h·ªìng cho th√°ng n√†y")
        else:
            explanation.append("   ‚ùå CUSTOMER KH√îNG ƒê·ª¶ ƒêI·ªÄU KI·ªÜN NH·∫¨N TH∆Ø·ªûNG")
            if not program_registration.is_active:
                explanation.append("   üìã L√Ω do: ƒêƒÉng k√Ω kh√¥ng active")
            else:
                explanation.append("   üìã L√Ω do: Kh√¥ng ƒë·∫°t ti√™u ch√≠")
                explanation.append("   üìã Chi ti·∫øt th·∫•t b·∫°i:")
                for failure in failed_conditions:
                    explanation.append(f"      ‚Ä¢ {failure}")
        
        explanation.append("")
        explanation.append("=" * 80)
        
        return "\n".join(explanation)
